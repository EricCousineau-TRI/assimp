From: =?utf-8?q?=22IOhannes_m_zm=C3=B6lnig_=28Debian/GNU=29=22?=
 <umlaeute@debian.org>
Date: Tue, 23 Oct 2018 21:49:33 +0200
Subject: simple dylib loading by using ctypes functionality

simplified original (complicated and somewhat broken) dylib loading
functionality with code suggested by Jakub Wilk.
This has not been forwarded (yet) to upstream, as the fix will not
work on platforms such as w32
Forwarded: no
Last-Updated: 2015-08-10
---
 port/PyAssimp/pyassimp/helper.py | 126 +++++----------------------------------
 port/PyAssimp/setup.py           |   2 -
 2 files changed, 14 insertions(+), 114 deletions(-)

diff --git a/port/PyAssimp/pyassimp/helper.py b/port/PyAssimp/pyassimp/helper.py
index 85bb53a..031ec54 100644
--- a/port/PyAssimp/pyassimp/helper.py
+++ b/port/PyAssimp/pyassimp/helper.py
@@ -7,7 +7,7 @@ Some fancy helper functions.
 import os
 import ctypes
 from ctypes import POINTER
-import operator
+import sys
 
 from distutils.sysconfig import get_python_lib
 import re
@@ -20,42 +20,6 @@ import logging;logger = logging.getLogger("pyassimp")
 
 from .errors import AssimpError
 
-additional_dirs, ext_whitelist = [],[]
-
-# populate search directories and lists of allowed file extensions
-# depending on the platform we're running on.
-if os.name=='posix':
-    additional_dirs.append('./')
-    additional_dirs.append('/usr/lib/')
-    additional_dirs.append('/usr/lib/x86_64-linux-gnu')
-    additional_dirs.append('/usr/local/lib/')
-
-    if 'LD_LIBRARY_PATH' in os.environ:
-        additional_dirs.extend([item for item in os.environ['LD_LIBRARY_PATH'].split(':') if item])
-
-    # check if running from anaconda.
-    if "conda" or "continuum" in sys.version.lower():
-      cur_path = get_python_lib()
-      pattern = re.compile('.*\/lib\/')
-      conda_lib = pattern.match(cur_path).group()
-      logger.info("Adding Anaconda lib path:"+ conda_lib)
-      additional_dirs.append(conda_lib)
-
-    # note - this won't catch libassimp.so.N.n, but
-    # currently there's always a symlink called
-    # libassimp.so in /usr/local/lib.
-    ext_whitelist.append('.so')
-    # libassimp.dylib in /usr/local/lib
-    ext_whitelist.append('.dylib')
-
-elif os.name=='nt':
-    ext_whitelist.append('.dll')
-    path_dirs = os.environ['PATH'].split(';')
-    for dir_candidate in path_dirs:
-        if 'assimp' in dir_candidate.lower():
-            additional_dirs.append(dir_candidate)
-
-#print(additional_dirs)
 def vec2tuple(x):
     """ Converts a VECTOR3D to a Tuple """
     return (x.x, x.y, x.z)
@@ -161,43 +125,6 @@ def get_bounding_box_for_node(node, bb_min, bb_max, transformation):
 
     return bb_min, bb_max
 
-def try_load_functions(library_path, dll):
-    '''
-    Try to bind to aiImportFile and aiReleaseImport
-
-    Arguments
-    ---------
-    library_path: path to current lib
-    dll:          ctypes handle to library
-
-    Returns
-    ---------
-    If unsuccessful:
-        None
-    If successful:
-        Tuple containing (library_path,
-                          load from filename function,
-                          load from memory function,
-                          export to filename function,
-                          release function,
-                          ctypes handle to assimp library)
-    '''
-
-    try:
-        load     = dll.aiImportFile
-        release  = dll.aiReleaseImport
-        load_mem = dll.aiImportFileFromMemory
-        export   = dll.aiExportScene
-    except AttributeError:
-        #OK, this is a library, but it doesn't have the functions we need
-        return None
-
-    # library found!
-    from .structs import Scene
-    load.restype = POINTER(Scene)
-    load_mem.restype = POINTER(Scene)
-    return (library_path, load, load_mem, export, release, dll)
-
 def search_library():
     '''
     Loads the assimp library.
@@ -209,8 +136,6 @@ def search_library():
                      release function,
                      dll)
     '''
-    #this path
-    folder = os.path.dirname(__file__)
 
     # silence 'DLL not found' message boxes on win
     try:
@@ -218,46 +143,23 @@ def search_library():
     except AttributeError:
         pass
 
-    candidates = []
-    # test every file
-    for curfolder in [folder]+additional_dirs:
-        if os.path.isdir(curfolder):
-            for filename in os.listdir(curfolder):
-                # our minimum requirement for candidates is that
-                # they should contain 'assimp' somewhere in
-                # their name
-                if filename.lower().find('assimp')==-1 or\
-                    os.path.splitext(filename)[-1].lower() not in ext_whitelist:
-                    continue
-
-                library_path = os.path.join(curfolder, filename)
-                logger.debug('Try ' + library_path)
-                try:
-                    dll = ctypes.cdll.LoadLibrary(library_path)
-                except Exception as e:
-                    logger.warning(str(e))
-                    # OK, this except is evil. But different OSs will throw different
-                    # errors. So just ignore any errors.
-                    continue
-                # see if the functions we need are in the dll
-                loaded = try_load_functions(library_path, dll)
-                if loaded: candidates.append(loaded)
-
-    if not candidates:
-        # no library found
+    libassimp = 'libassimp.so.4'
+    LIBASSIMP = ctypes.CDLL(libassimp)
+    try:
+        load = LIBASSIMP.aiImportFile
+        load_mem = LIBASSIMP.aiImportFileFromMemory
+        export = LIBASSIMP.aiExportScene
+        release = LIBASSIMP.aiReleaseImport
+    except AttributeError:
+        #OK, this is a library, but it has not the functions we need
         raise AssimpError("assimp library not found")
     else:
         # get the newest library_path
-        candidates = map(lambda x: (os.lstat(x[0])[-2], x), candidates)
-        res = max(candidates, key=operator.itemgetter(0))[1]
-        logger.debug('Using assimp library located at ' + res[0])
-
-        # XXX: if there are 1000 dll/so files containing 'assimp'
-        # in their name, do we have all of them in our address
-        # space now until gc kicks in?
+        #Library found!
+        from . import structs
+        load.restype = POINTER(structs.Scene)
 
-        # XXX: take version postfix of the .so on linux?
-        return res[1:]
+    return(load, load_mem, export, release, LIBASSIMP)
 
 def hasattr_silent(object, name):
     """
diff --git a/port/PyAssimp/setup.py b/port/PyAssimp/setup.py
index 26cf9b4..b71a1bf 100644
--- a/port/PyAssimp/setup.py
+++ b/port/PyAssimp/setup.py
@@ -9,8 +9,6 @@ setup(name='pyassimp',
       url='https://github.com/assimp/assimp',
       packages=['pyassimp'],
       data_files=[
-                  ('share/pyassimp', ['README.md']),
-                  ('share/examples/pyassimp', ['scripts/' + f for f in os.listdir('scripts/')])
                  ],
       requires=['numpy']
       )
